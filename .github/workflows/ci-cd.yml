name: CI/CD Pipeline

on:
  push:
    branches: [ main, 'dev-*', 'feature-*', 'hotfix-*', 'release-*' ]
    tags: [ 'v*' ]
    paths-ignore:
      - '*.md'
      - '**/*.md'
      - 'docs/**'
  pull_request:
    branches: [ main, 'dev-*', 'feature-*', 'hotfix-*', 'release-*' ]
    paths-ignore:
      - '*.md'
      - '**/*.md'
      - 'docs/**'

env:
  REGISTRY: docker.io
  IMAGE_NAME: captnio/captn

jobs:
  # Stage 0: Check if code changes were made (skip docs-only changes)
  check-changes:
    name: Check for Code Changes
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.filter.outputs.should_build }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check changed files
      id: filter
      run: |
        # Get list of changed files
        if [ "${{ github.event_name }}" == "pull_request" ]; then
          CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }})
        else
          # For push events, compare with previous commit
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
        fi

        echo "Changed files:"
        echo "$CHANGED_FILES"

        # Check if any non-documentation files were changed
        SHOULD_BUILD="false"

        while IFS= read -r file; do
          # Skip if file is markdown or in docs/ directory
          if [[ "$file" != *.md ]] && [[ "$file" != docs/* ]]; then
            # Skip if file is the CI/CD workflow itself
            if [[ "$file" != .github/workflows/ci-cd.yml ]]; then
              echo "Code change detected: $file"
              SHOULD_BUILD="true"
              break
            fi
          fi
        done <<< "$CHANGED_FILES"

        echo "should_build=$SHOULD_BUILD" >> $GITHUB_OUTPUT
        echo "Build required: $SHOULD_BUILD"

  # Stage 1: License Check - Must pass for everything else to proceed
  license-check:
    name: License Compliance Check
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.outputs.should_build == 'true'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install pip-licenses
      run: |
        python -m pip install --upgrade pip
        pip install pip-licenses

    - name: Install project dependencies
      run: |
        pip install -r requirements.txt

    - name: Check licenses compatibility
      run: |
        echo "=== Checking license compatibility with AGPL-3.0 ==="
        echo ""
        echo "Allowed licenses (AGPL-3.0 compatible):"
        echo "  - Apache-2.0, Apache Software License"
        echo "  - MIT, MIT License"
        echo "  - BSD-2-Clause, BSD-3-Clause, BSD License"
        echo "  - MPL-2.0, Mozilla Public License 2.0"
        echo "  - Python Software Foundation License"
        echo "  - ISC License (ISC)"
        echo ""

        # Generate license report and check compatibility
        pip-licenses \
          --format=markdown \
          --with-license-file \
          --no-license-path \
          --allow-only="\
            Apache-2.0;\
            Apache Software License;\
            MIT;\
            MIT License;\
            BSD-2-Clause;\
            BSD-3-Clause;\
            BSD License;\
            BSD;\
            MPL-2.0;\
            Mozilla Public License 2.0 (MPL 2.0);\
            Python Software Foundation License;\
            ISC;\
            ISC License (ISCL)"

        # Check if the command succeeded
        if [ $? -ne 0 ]; then
          echo "âŒ ERROR: Found dependencies with incompatible licenses!"
          echo "Please review the output above and replace incompatible dependencies."
          exit 1
        fi

        echo ""
        echo "âœ… All dependencies are compatible with AGPL-3.0!"

    - name: Generate detailed license report
      if: always()
      run: |
        echo "=== Detailed License Report ==="
        pip-licenses --format=markdown --with-license-file --no-license-path

    - name: Generate JSON report for artifacts
      if: always()
      run: |
        pip-licenses --format=json --with-license-file --no-license-path > license-report.json

    - name: Upload license report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: license-report
        path: license-report.json
        retention-days: 90

  # Stage 2: Create Release (only on main branch)
  release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [check-changes, license-check]
    if: |
      (needs.check-changes.outputs.should_build == 'true' || github.ref == 'refs/heads/main') &&
      github.ref == 'refs/heads/main' &&
      github.event_name != 'pull_request'
    permissions:
      contents: write

    outputs:
      version: ${{ steps.version.outputs.version }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Get version from app
      id: version
      run: |
        VERSION=$(python -c "import app; print(app.__version__)")
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"

    - name: Create Release Archive
      run: |
        # Create a clean archive without .git
        tar --exclude='.git' \
            --exclude='.github' \
            --exclude='__pycache__' \
            --exclude='*.pyc' \
            --exclude='.gitignore' \
            --exclude='app/logs/*' \
            -czf captn-${{ steps.version.outputs.version }}.tar.gz \
            app/ docker/ docs/ requirements.txt README.md LICENSE

        # Create checksums
        sha256sum captn-${{ steps.version.outputs.version }}.tar.gz > captn-${{ steps.version.outputs.version }}.tar.gz.sha256

    - name: Check if release exists
      id: check_release
      run: |
        if gh release view v${{ steps.version.outputs.version }} &> /dev/null; then
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "exists=false" >> $GITHUB_OUTPUT
        fi
      env:
        GH_TOKEN: ${{ github.token }}

    - name: Create Release
      id: create_release
      if: steps.check_release.outputs.exists == 'false'
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ steps.version.outputs.version }}
        name: Release v${{ steps.version.outputs.version }}
        draft: false
        prerelease: false
        generate_release_notes: true
        files: |
          captn-${{ steps.version.outputs.version }}.tar.gz
          captn-${{ steps.version.outputs.version }}.tar.gz.sha256
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Release Info
      if: steps.check_release.outputs.exists == 'false'
      run: |
        echo "âœ… Release v${{ steps.version.outputs.version }} created successfully!"
        echo "ðŸ“¦ Archive: captn-${{ steps.version.outputs.version }}.tar.gz"

  # Stage 3: Build and Push Docker Image (main, dev-* and release-* branches)
  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [check-changes, license-check]
    if: |
      (needs.check-changes.outputs.should_build == 'true' || github.ref == 'refs/heads/main') &&
      github.event_name != 'pull_request' &&
      (github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/heads/dev-') || startsWith(github.ref, 'refs/heads/release-'))
    permissions:
      contents: read
      packages: write
      security-events: write
      actions: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Get version from app
      id: version
      run: |
        VERSION=$(python -c "import app; print(app.__version__)")
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "major=$(echo $VERSION | cut -d. -f1)" >> $GITHUB_OUTPUT
        echo "minor=$(echo $VERSION | cut -d. -f2)" >> $GITHUB_OUTPUT
        echo "patch=$(echo $VERSION | cut -d. -f3)" >> $GITHUB_OUTPUT

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=pr
          type=ref,event=branch,enable=${{ startsWith(github.ref, 'refs/heads/dev-') }}
          type=ref,event=branch,enable=${{ startsWith(github.ref, 'refs/heads/feature-') }}
          type=ref,event=branch,enable=${{ startsWith(github.ref, 'refs/heads/hotfix-') }}
          type=ref,event=branch,enable=${{ startsWith(github.ref, 'refs/heads/release-') }}
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ steps.version.outputs.version }},enable={{is_default_branch}}
        labels: |
          org.opencontainers.image.title=captn
          org.opencontainers.image.description=Intelligent, rule-based container updater that automatically manages container updates using semantic versioning and registry metadata
          org.opencontainers.image.vendor=captn.io
          org.opencontainers.image.licenses=AGPL-3.0
          org.opencontainers.image.version=${{ steps.version.outputs.version }}
          org.opencontainers.image.authors=captn.io <captn-io@jk-net.com>
          org.opencontainers.image.url=https://github.com/captn-io/captn
          org.opencontainers.image.source=https://github.com/captn-io/captn
          org.opencontainers.image.documentation=https://github.com/captn-io/captn/blob/main/README.md
          org.opencontainers.image.base.name=docker.io/library/alpine:3.21.3
          maintainer=captn.io <captn-io@jk-net.com>

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/DOCKERFILE
        platforms: linux/amd64,linux/arm64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          VERSION=${{ steps.version.outputs.version }}
          REVISION=${{ github.sha }}
          CREATED=${{ github.event.head_commit.timestamp }}

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}
        format: 'table'
        exit-code: '0'
        ignore-unfixed: true
        vuln-type: 'os,library'

  test:
    runs-on: ubuntu-latest
    needs: [check-changes, build]
    if: |
      needs.check-changes.outputs.should_build == 'true' &&
      github.event_name != 'pull_request'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Determine image tag
      id: image_tag
      run: |
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          echo "tag=latest" >> $GITHUB_OUTPUT
          echo "Using tag: latest (main branch)"
        else
          # For branch builds, use the branch name as tag
          BRANCH_NAME="${{ github.ref_name }}"
          echo "tag=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "Using tag: $BRANCH_NAME (branch build)"
        fi

    - name: Pull and test image
      run: |
        IMAGE_TAG="${{ steps.image_tag.outputs.tag }}"
        echo "Pulling image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG"
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG
        
        # Test basic functionality
        docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG captn --help
        docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG captn --version
        echo "Image test completed successfully"

    - name: Extract example config from container
      run: |
        IMAGE_TAG="${{ steps.image_tag.outputs.tag }}"
        
        # Create temporary directory for config
        mkdir -p /tmp/captn-conf
        
        # Run container
        echo "Extracting config from image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG"
        docker run -d --name captn -v /var/run/docker.sock:/var/run/docker.sock -v /tmp/captn-conf:/app/conf ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG

        # Trigger example config creation
        docker exec captn captn --filter name=nginx --dry-run

        # Remove container
        docker rm -f captn
        
        # Verify the example config was created
        if [ ! -f /tmp/captn-conf/captn.example.cfg ]; then
          echo "ERROR: captn.example.cfg was not created"
          echo "Contents of /tmp/captn-conf:"
          ls -la /tmp/captn-conf/ || echo "Directory not accessible"
          exit 1
        fi
        
        echo "âœ… Successfully extracted captn.example.cfg from container"
        ls -lh /tmp/captn-conf/captn.example.cfg

    - name: Upload example config as artifact
      uses: actions/upload-artifact@v4
      with:
        name: captn-example-config
        path: /tmp/captn-conf/captn.example.cfg
        retention-days: 1

  security:
    runs-on: ubuntu-latest
    needs: [check-changes, build]
    if: |
      needs.check-changes.outputs.should_build == 'true' &&
      github.event_name != 'pull_request'

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Pull image for Snyk scan
      run: |
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

    - name: Run Snyk to check for vulnerabilities
      continue-on-error: true # Needed as long as the repository is private
      uses: snyk/actions/docker@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        args: --severity-threshold=high

  # Stage 5: Update version numbers in Markdown files (all branches EXCEPT main)
  update-version-docs:
    name: Update Version in Documentation
    runs-on: ubuntu-latest
    needs: [build]
    if: |
      github.event_name != 'pull_request' &&
      github.ref != 'refs/heads/main' &&
      (startsWith(github.ref, 'refs/heads/dev-') || startsWith(github.ref, 'refs/heads/feature-') || startsWith(github.ref, 'refs/heads/hotfix-') || startsWith(github.ref, 'refs/heads/release-'))
    permissions:
      contents: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: ${{ github.ref_name }}

    - name: Get version from app
      id: version
      run: |
        VERSION=$(python -c "import app; print(app.__version__)")
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Current version: $VERSION"

    - name: Update version in Markdown files
      run: |
        VERSION="${{ steps.version.outputs.version }}"

        echo "ðŸ” Searching for version references in Markdown files..."

        # Find all markdown files
        MARKDOWN_FILES=$(find . -type f -name "*.md" -not -path "./.*")

        # Pattern for version numbers (e.g., 0.8.0, 1.2.3, etc.)
        # This will match version patterns in various contexts
        VERSION_PATTERN='[0-9]+\.[0-9]+\.[0-9]+'

        # Create a backup of changes
        CHANGES_MADE=false

        for file in $MARKDOWN_FILES; do
          echo "Checking: $file"

          # Check if file contains version patterns
          if grep -E "$VERSION_PATTERN" "$file" > /dev/null 2>&1; then
            echo "  Found version references in $file"

            # Update Docker image version references (e.g., captnio/captn:0.8.0)
            if grep -E "captnio/captn:[0-9]+\.[0-9]+\.[0-9]+" "$file" > /dev/null 2>&1; then
              sed -i "s/captnio\/captn:[0-9]\+\.[0-9]\+\.[0-9]\+/captnio\/captn:$VERSION/g" "$file"
              echo "  âœ“ Updated Docker image version"
              CHANGES_MADE=true
            fi

            # Update version badge references (e.g., in shields.io badges)
            if grep -E "release/v[0-9]+\.[0-9]+\.[0-9]+" "$file" > /dev/null 2>&1; then
              sed -i "s/release\/v[0-9]\+\.[0-9]\+\.[0-9]\+/release\/v$VERSION/g" "$file"
              echo "  âœ“ Updated release badge version"
              CHANGES_MADE=true
            fi

            # Update download links (e.g., captn-0.8.0.tar.gz)
            if grep -E "captn-[0-9]+\.[0-9]+\.[0-9]+\.tar\.gz" "$file" > /dev/null 2>&1; then
              sed -i "s/captn-[0-9]\+\.[0-9]\+\.[0-9]\+\.tar\.gz/captn-$VERSION.tar.gz/g" "$file"
              echo "  âœ“ Updated download links"
              CHANGES_MADE=true
            fi

            # Update standalone version numbers in code blocks (e.g., CLI output examples)
            # This specifically targets the pattern in CLI reference documentation
            if grep -E "^\`\`\`$" "$file" > /dev/null 2>&1; then
              # Use perl for multiline matching: ```\n<version>\n```
              if perl -0777 -pe "s/(\`\`\`\n)[0-9]+\.[0-9]+\.[0-9]+(\n\`\`\`)/\${1}$VERSION\${2}/g" "$file" > "$file.tmp"; then
                if ! cmp -s "$file" "$file.tmp"; then
                  mv "$file.tmp" "$file"
                  echo "  âœ“ Updated standalone version in code blocks"
                  CHANGES_MADE=true
                else
                  rm "$file.tmp"
                fi
              else
                rm -f "$file.tmp"
              fi
            fi
          fi
        done

        if [ "$CHANGES_MADE" = true ]; then
          echo ""
          echo "âœ… Version numbers updated to $VERSION"
        else
          echo ""
          echo "â„¹ï¸  No version references found to update"
        fi

    - name: Check for changes
      id: check_changes
      run: |
        if git diff --quiet; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "No changes to commit"
        else
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "Changes detected:"
          git diff --stat
        fi

    - name: Commit and push changes
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add *.md docs/*.md
        git commit -m "chore: update version to ${{ steps.version.outputs.version }} in documentation [skip ci]"
        git push origin HEAD:${{ github.ref_name }}

    - name: Summary
      run: |
        echo "## Version Update Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ“¦ Version: \`${{ steps.version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        if [ "${{ steps.check_changes.outputs.has_changes }}" = "true" ]; then
          echo "âœ… Documentation updated successfully" >> $GITHUB_STEP_SUMMARY
        else
          echo "â„¹ï¸  No documentation updates needed" >> $GITHUB_STEP_SUMMARY
        fi

  # Stage 6: Update configuration example in documentation (all branches EXCEPT main)
  update-config-docs:
    name: Update Configuration Example
    runs-on: ubuntu-latest
    needs: [test, update-version-docs]
    if: |
      github.event_name != 'pull_request' &&
      github.ref != 'refs/heads/main' &&
      (startsWith(github.ref, 'refs/heads/dev-') || startsWith(github.ref, 'refs/heads/feature-') || startsWith(github.ref, 'refs/heads/hotfix-') || startsWith(github.ref, 'refs/heads/release-'))
    permissions:
      contents: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: ${{ github.ref_name }}

    - name: Download example config artifact
      uses: actions/download-artifact@v4
      with:
        name: captn-example-config
        path: /tmp/captn-conf

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Update configuration example in documentation
      run: |
        python3 << 'EOF'
        import sys

        # Read the generated example config
        with open('/tmp/captn-conf/captn.example.cfg', 'r', encoding='utf-8') as f:
            example_content = f.read()

        # Find the [general] section (start of actual config)
        lines = example_content.split('\n')
        config_start = None
        for i, line in enumerate(lines):
            if line.strip() == '[general]':
                config_start = i
                break

        if config_start is None:
            print("ERROR: Could not find [general] section in example config")
            sys.exit(1)

        # Extract everything from [general] onwards
        config_example = '\n'.join(lines[config_start:])

        # Read the documentation file
        with open('docs/03-Configuration.md', 'r', encoding='utf-8') as f:
            doc_content = f.read()

        # Find the configuration example section
        # Look for: ```ini followed by # captn Configuration
        doc_start_marker = '```ini\n# captn Configuration\n# ==================='
        doc_start_idx = doc_content.find(doc_start_marker)
        if doc_start_idx == -1:
            print("ERROR: Could not find configuration example start marker in documentation")
            sys.exit(1)

        # Find the end: next ``` after the start marker
        search_start = doc_start_idx + len(doc_start_marker)
        doc_end_marker = '\n```'
        doc_end_idx = doc_content.find(doc_end_marker, search_start)
        if doc_end_idx == -1:
            print("ERROR: Could not find configuration example end marker in documentation")
            sys.exit(1)

        # Build the new content
        new_doc_content = (
            doc_content[:doc_start_idx + len(doc_start_marker)] +
            '\n\n' +
            config_example +
            doc_content[doc_end_idx:]
        )

        # Write the updated documentation
        with open('docs/03-Configuration.md', 'w', encoding='utf-8') as f:
            f.write(new_doc_content)

        print("âœ… Configuration example updated successfully in docs/03-Configuration.md")
        EOF

    - name: Check for changes
      id: check_changes
      run: |
        if git diff --quiet docs/03-Configuration.md; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "No changes to commit"
        else
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "Changes detected:"
          git diff --stat docs/03-Configuration.md
        fi

    - name: Commit and push changes
      if: steps.check_changes.outputs.has_changes == 'true'
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add docs/03-Configuration.md
        git commit -m "chore: update configuration example in documentation [skip ci]"
        git push origin HEAD:${{ github.ref_name }}

    - name: Summary
      run: |
        echo "## Configuration Example Update" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        if [ "${{ steps.check_changes.outputs.has_changes }}" = "true" ]; then
          echo "âœ… Configuration example updated successfully" >> $GITHUB_STEP_SUMMARY
        else
          echo "â„¹ï¸  No configuration example updates needed" >> $GITHUB_STEP_SUMMARY
        fi

  # Stage 7: Update Docker Hub README - runs on main branch after build
  update-dockerhub-readme:
    name: Update Docker Hub README
    runs-on: ubuntu-latest
    needs: [build]
    if: |
      github.ref == 'refs/heads/main' &&
      github.event_name != 'pull_request'
    permissions:
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: main

    - name: Update Docker Hub Description
      uses: peter-evans/dockerhub-description@v4
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
        repository: ${{ env.IMAGE_NAME }}
        short-description: ${{ github.event.repository.description }}
        readme-filepath: ./README.md

    - name: Summary
      run: |
        echo "## Docker Hub README Update" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "âœ… Docker Hub README updated successfully" >> $GITHUB_STEP_SUMMARY
        echo "ðŸ”— [View on Docker Hub](https://hub.docker.com/r/${{ env.IMAGE_NAME }})" >> $GITHUB_STEP_SUMMARY

  # Stage 8: Cleanup branch images after merge to main
  cleanup-branch-images:
    name: Cleanup Branch Docker Images
    runs-on: ubuntu-latest
    needs: [build]
    if: |
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push' &&
      !contains(github.event.head_commit.message, '[skip ci]')
    permissions:
      contents: read

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: main
        fetch-depth: 2

    - name: Detect merged branch
      id: detect_branch
      run: |
        # Try to detect the source branch from the merge commit
        # Method 1: Check if this is a merge commit
        PARENT_COUNT=$(git rev-list --parents -n 1 HEAD | wc -w)
        
        if [ $PARENT_COUNT -gt 2 ]; then
          # This is a merge commit, get the branch name from commit message
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          echo "Commit message: $COMMIT_MSG"
          
          # Extract branch name from merge commit message (format: "Merge branch 'branch-name' into main")
          if [[ "$COMMIT_MSG" =~ Merge.*branch[[:space:]][\'\"]([^\'\"]+)[\'\"] ]]; then
            BRANCH_NAME="${BASH_REMATCH[1]}"
            # Remove origin/ prefix if present
            BRANCH_NAME="${BRANCH_NAME#origin/}"
            echo "Detected merged branch: $BRANCH_NAME"
            echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
            echo "is_merge=true" >> $GITHUB_OUTPUT
          else
            echo "Could not extract branch name from merge commit"
            echo "is_merge=false" >> $GITHUB_OUTPUT
          fi
        else
          echo "Not a merge commit, skipping cleanup"
          echo "is_merge=false" >> $GITHUB_OUTPUT
        fi

    - name: Get Docker Hub token
      id: docker_token
      if: steps.detect_branch.outputs.is_merge == 'true'
      run: |
        # Get Docker Hub authentication token
        TOKEN=$(curl -s -X POST \
          -H "Content-Type: application/json" \
          -d '{"username": "${{ secrets.DOCKERHUB_USERNAME }}", "password": "${{ secrets.DOCKERHUB_TOKEN }}"}' \
          https://hub.docker.com/v2/users/login/ | jq -r .token)
        
        if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
          echo "Failed to get Docker Hub token"
          exit 1
        fi
        
        echo "token=$TOKEN" >> $GITHUB_OUTPUT
        echo "âœ… Successfully authenticated with Docker Hub"

    - name: Check if image exists
      id: check_image
      if: steps.detect_branch.outputs.is_merge == 'true'
      run: |
        BRANCH_NAME="${{ steps.detect_branch.outputs.branch_name }}"
        TOKEN="${{ steps.docker_token.outputs.token }}"
        
        # Extract repository name from IMAGE_NAME (format: namespace/repository)
        NAMESPACE=$(echo "${{ env.IMAGE_NAME }}" | cut -d'/' -f1)
        REPO=$(echo "${{ env.IMAGE_NAME }}" | cut -d'/' -f2)
        
        echo "Checking for image: ${{ env.IMAGE_NAME }}:$BRANCH_NAME"
        
        # Check if the tag exists
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
          -H "Authorization: Bearer $TOKEN" \
          "https://hub.docker.com/v2/namespaces/$NAMESPACE/repositories/$REPO/tags/$BRANCH_NAME")
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "image_exists=true" >> $GITHUB_OUTPUT
          echo "âœ… Image tag '$BRANCH_NAME' exists"
        else
          echo "image_exists=false" >> $GITHUB_OUTPUT
          echo "â„¹ï¸  Image tag '$BRANCH_NAME' does not exist (HTTP $HTTP_CODE)"
        fi

    - name: Delete branch image
      if: |
        steps.detect_branch.outputs.is_merge == 'true' &&
        steps.check_image.outputs.image_exists == 'true'
      run: |
        BRANCH_NAME="${{ steps.detect_branch.outputs.branch_name }}"
        TOKEN="${{ steps.docker_token.outputs.token }}"
        
        # Extract repository name from IMAGE_NAME
        NAMESPACE=$(echo "${{ env.IMAGE_NAME }}" | cut -d'/' -f1)
        REPO=$(echo "${{ env.IMAGE_NAME }}" | cut -d'/' -f2)
        
        echo "ðŸ—‘ï¸  Deleting image: ${{ env.IMAGE_NAME }}:$BRANCH_NAME"
        
        # Delete the tag
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
          -H "Authorization: Bearer $TOKEN" \
          "https://hub.docker.com/v2/namespaces/$NAMESPACE/repositories/$REPO/tags/$BRANCH_NAME")
        
        if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "200" ]; then
          echo "âœ… Successfully deleted image tag '$BRANCH_NAME'"
        else
          echo "âš ï¸  Failed to delete image tag '$BRANCH_NAME' (HTTP $HTTP_CODE)"
          exit 1
        fi

    - name: Summary
      if: always()
      run: |
        echo "## Branch Image Cleanup" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ steps.detect_branch.outputs.is_merge }}" = "true" ]; then
          BRANCH_NAME="${{ steps.detect_branch.outputs.branch_name }}"
          echo "ðŸ” Detected merged branch: \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check_image.outputs.image_exists }}" = "true" ]; then
            echo "âœ… Deleted Docker image: \`${{ env.IMAGE_NAME }}:$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "â„¹ï¸  No Docker image found for branch \`$BRANCH_NAME\`" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "â„¹ï¸  No merge detected, skipping cleanup" >> $GITHUB_STEP_SUMMARY
        fi
